package Extlib;

=head1 NAME

Extlib

=head1 SYNOPSIS

This system does an install of the modules in modules.yaml, then uses
the install.json files generated by cpanm to construct an 'extlib.json' file, which contains
the meta for all of the modules found in the extlib/lib/perl5/{arch}/.meta
directory.

The 'extlib.json' file is used to construct the 02packages.details.txt file.
The reason for this process is that it's very difficult (and sometimes
impossible) to determine the actual prereqs until the module is installed.
All methods to determine prereqs without installing have various failures.
It's also hard to determine which packages are actually installed.

So the general source update process is:

  1) create a list of desired modules
  2) install them into a bare local lib (which also downloads source)
  3) gather the meta information from the {arch}/.meta directory
  4) construct an 02packages.details.txt file from the meta information

After this process is finished, we now have a custom CPAN mirror, which
can be used to install the extlib fairly simply using cpanm.

This is a custom implementation of a local lib, based on Carton. Carton did not have
the ability to specify some of the information that we use in this process, could
not natively do "update all non-pinned source", and did not handle a number of the
issues, such as removing duplicates.

Since this was initially written, Carton has switched to a different format for
the carton.lock/carton.snapshot file. It would probably be possible to use that
format instead, but it's missing some information that is used here. This
also doesn't use a cpanfile, because I wanted to store some information with
the specification that cpanfile doesn't handle, such as that the path is for
a locally patched file, that the tests are failing (notest) and that the
package needs to be forced.

Carton also didn't have the ability to customize the location of various
files, which we wanted for our system.

The Carton code is designed to be used from the command line and doing
complicated things like this through a system call is suboptimal. There
are so many changes to the process, that there wasn't much point in
using the Carton code directly. However it would be possible to create
workalike versions of the Carton commands if desired.

=cut

use strict;
use warnings;
use Term::ANSIColor ('colored');
use Config qw(%Config);
our $DefaultMirror = 'http://cpan.metacpan.org/';
use Extlib::ModuleSpec;
use File::Path ('remove_tree');
use Try::Tiny;
use Digest::MD5::File ('file_md5_hex');
use Cpanel::JSON::XS;
use File::Spec::Functions ('splitpath');
use File::Path            ('make_path');
use IO::All;
use Extlib::Tree;
use File::Find;
use CPAN::Meta;
use IO::Compress::Gzip;
use Module::CoreList;
use version;

use constant { SUCCESS => 0, INFO => 1, WARN => 2, ERROR => 3 };

our $Colors = {
    SUCCESS
    , => 'green',
    WARN
    , => 'yellow',
    INFO
    ,      => 'cyan',
    ERROR, => 'red',
};

=head2 new

=cut

sub new {
    my ( $class, %args ) = @_;
    bless {
        path   => $args{path}   || 'local',
        mirror => $args{mirror} || $DefaultMirror,
        modspec_file     => $args{modspec_file},
        mirror_meta_file => $args{mirror_meta_file} || 'extlib.json',
        color            => 1,
        cpanm_executable => $args{cpanm_executable},
        last_run_file    => $args{last_run_file},
    }, $class;
}

=head2 update

Single method update source.

=cut

sub update {
    my ( $self, $modules ) = @_;

    $self->print( "Updating modules\n", INFO );
    $self->install_for_update_individually;
    my ( $installs, $to_remove ) = $self->check_meta_for_update;
    $self->build_mirror_meta_and_clean( $installs, $to_remove );;
    $self->clean_local_mirror;
    $self->build_index;
    $self->build_packages_details;
    $self->build_distfiles;
    $self->printf( "Complete! Modules were installed into %s\n", $self->{path}, SUCCESS );
}

=head1 Accessors

=head2 mirror_meta

=cut

sub mirror_meta {
    my $self = shift;
    return $self->{mirror_meta} if $self->{mirror_meta};
    $self->get_mirror_meta;
    return $self->{mirror_meta};
}

=head2 index

=cut

sub index {
    my $self = shift;
    return $self->{index} if $self->{index};
    $self->build_index;
    return $self->{index};
}

=head2 path

=cut

sub path {
    my $self = shift;
    return $self->{path};
}

=head2 local_mirror

=cut

sub local_mirror { File::Spec->rel2abs("$_[0]->{path}/src") }

=head2 mirror_meta_file

=cut

sub mirror_meta_file {
    my $self = shift;
    $self->{mirror_meta_file} || 'extlib.json';
}

=head2  etc_file

=cut

sub etc_file {
    my ( $self, $file ) = @_;
    $self->{etc_dir} = $self->path . "/etc";
    mkdir $self->{etc_dir}, 0777 unless -e $self->{etc_dir};
    return "$self->{etc_dir}/$file";
}

=head2 modules_file

=cut

sub modules_file {
    my ( $self, $file ) = @_;
    $self->{modules_dir} = $self->local_mirror . '/modules';
    mkdir $self->{modules_dir}, 0777 unless -e $self->{modules_dir};
    return "$self->{modules_dir}/$file";
}

=head2 packages_details_file

=cut

sub packages_details_file {
    my $self = shift;
    return $self->modules_file("02packages.details.txt");
}

=head2 modspec

=cut

sub modspec {
    my $self = shift;
    $self->{modspec} = Extlib::ModuleSpec->new( $self->{modspec_file} )
        unless $self->{modspec};
    return $self->{modspec};
}

=head2 module_list

=cut

sub module_list {
    my $self = shift;
    return $self->modspec->modules;
}

sub last_run_file {
    my $self = shift;
    return $self->{last_run_file};
}


=head1 Utility methods

=head2 printf

=cut

sub printf {
    my $self = shift;
    my $type = pop;
    my ( $temp, @args ) = @_;
    $self->print( sprintf( $temp, @args ), $type );
}

=head2 print

=cut

sub print {
    my ( $self, $msg, $type ) = @_;
    $msg = colored $msg, $Colors->{$type} if defined $type && $self->{color};
    my $fh = $type && $type >= WARN ? *STDERR : *STDOUT;
    print {$fh} $msg;
}

sub pad {
    my ( $str, $len, $left ) = @_;

    my $howmany = $len - length($str);
    return $str if $howmany <= 0;

    my $pad = " " x $howmany;
    return $left ? "$pad$str" : "$str$pad";
}

=head1 Methods

=head2 build_distfiles

=cut

sub build_distfiles {
    my $self = shift;

    my $index = $self->index;
    my $file  = $self->etc_file('distfiles.txt');

    my %distributions;
    for my $module ( keys %$index ) {
        $distributions{ $index->{$module}->{meta}->{pathname} } = 1;
    }

    my $fh;
    open $fh, ">", $file or die $!;

    my @dists = keys %distributions;
    @dists = sort @dists;
    for my $dist (@dists) {
        print $fh sprintf( "%s\n", $dist );
    }

    return $file;
}

=head2 gather_installed_meta

Tthis returns an arrayref of all meta found in the {archname}/.meta directory

=cut

sub gather_installed_meta {
    my $self = shift;

    my $libdir = "$self->{path}/lib/perl5/$Config{archname}/.meta";
    return unless -e $libdir;

    # look in the .meta directory for all installed modules in the local lib
    my @installs;
    my $wanted = sub {
        if ( $_ eq 'install.json' ) {
            push @installs, [ $File::Find::name, "$File::Find::dir/MYMETA.json" ];
        }
    };
    File::Find::find( $wanted, $libdir );
    my @meta = map {
        my $module = load_json( $_->[0] );
        my $mymeta =
            -f $_->[1] ? CPAN::Meta->load_file( $_->[1] )->as_struct( { version => "2" } ) : {};
        ( { %$module, mymeta => $mymeta } )
    } @installs;

    return \@meta;
}

=head2 check_meta_for_update

Do a number of checks of installed modules against module spec and against archives

=cut

sub check_meta_for_update {
    my ( $self, $verbose ) = @_;

    $self->{verbose} = 1 if $verbose;
    $self->print( "Checking for additions and removals\n", INFO );

    # Load the json meta files from the local lib .meta directory
    my $installed_meta = $self->gather_installed_meta;

    # Index the meta records by 1) module name to distributions in %installed_modules,
    # 2) dist name in %installed_dists, 3) provided packages in %installed_provides.
    # There could be more than one distribution per module name
    my %installed_modules;
    my %installed_dists;
    my %installed_provides;
    my %installed_prereqs_required;
    my %installs;
    my %to_remove;
    $self->index_installed_meta(
        $installed_meta,
        \%installed_modules,
        \%installed_dists,
        \%installed_provides,
        \%installed_prereqs_required,
        \%installs,
        \%to_remove,
    );

    # check for packages specified in the module spec that didn't get installed
    # TODO: check for path, not module name, if path exists
    my $modspec_config = $self->modspec->config;
    my $meta_dir = "$self->{path}/lib/perl5/$Config{archname}/.meta";
    $self->print("Checking that all modules in " . $self->{modspec_file} . " have been installed.\n", INFO);
    foreach my $module_name ( keys %$modspec_config ) {
        $self->print("'Provides' for $module_name not found in $meta_dir. It may not have been installed, or install.json is incorrect\n", ERROR)
            unless exists $installed_provides{$module_name};
    }

    # verify that all prereqs have a matching installed dist
    $self->print("Check for missing prereqs.\n", INFO);
    foreach my $module_name ( keys %installed_prereqs_required ) {
        next if $module_name eq 'perl';
        $self->print("'Prereq' $module_name not found in $meta_dir. It may not have been installed, or install.json is incorrect\n", ERROR)
            unless $self->is_core($module_name, 0) || exists $installed_provides{$module_name};
    }
    $self->print("Done checking prereqs (count=" . scalar(keys %installed_prereqs_required) . ").\n", INFO);

    # TODO: Here we could attempt to remove prereqs of removed packages
    # At the moment, you need to run multiple passes of build-metadata and verify-update
    if ( keys %to_remove ) {
#       my $prereqs_to_remove = $self->collect_dists_to_remove(\%installs, \%to_remove);
#       foreach my $dist ( keys %$prereqs_to_remove ) {
#           $self->print("Will remove prereq $dist of removed dist.\n", INFO);
#       }
#       delete @installs{keys %$prereqs_to_remove};
        $self->print("*** Warning: distributions that conflict with a pinned dist have been removed.\n", INFO);
        $self->print("There is no guarantee that the remaining distributions will work correctly,\n", INFO);
        $self->print("and you may have to force or pin a dist with a removed prereq.\n", INFO);
        $self->print("Also - in order to remove unneeded installed prereqs you will need to run:\n", INFO);
        $self->print("1) build-metadata 2) verify-update 3) build-metadata, in order to do a \n", INFO);
        $self->print("a local lib only installation.\n", INFO);
    }


    # check installed packages against archives in mirror
    my $archives = $self->get_mirror_archives;
    $self->print("Checking current archives in mirror.\n", INFO);
    foreach my $dist ( keys %$archives ) {
        unless ( exists $installed_dists{$dist} ) {
            $self->print( "Would be removing $dist\n", INFO )
                if $verbose;
            unless ( exists $to_remove{$dist} ) {
                $to_remove{$dist} = $archives->{$dist};
            }
        }
    }

    # check last recorded installation in extlib.json against installed dists
    if ($verbose && -e $self->mirror_meta_file ) {
        $self->print("Checking currently installed against previous mirror meta " . $self->mirror_meta_file . "\n", INFO);
        my $mirror_meta = $self->mirror_meta->{modules};
        # create mirror_meta dist index
        my %mirror_meta_dists;
        foreach my $meta ( values %$mirror_meta ) {
            $mirror_meta_dists{ $meta->{dist} } = $meta;
        }
        my %former_dists;
        my $num_added = 0;
        foreach my $dist ( keys %installed_dists ) {
            unless ( exists $mirror_meta_dists{$dist} || exists $to_remove{$dist} ) {
                $self->print( "Would be adding $dist\n", INFO );
                $num_added++;
            }
        }
        if ( $num_added ) {
            $self->print( "Adding $num_added distributions.\n", INFO );
        }
        else {
            $self->print( "No distributions being added.\n", INFO );
        }
    }

    return \%installs, \%to_remove;
}

sub index_installed_meta {
    my ($self, $installed_meta, $installed_modules, $installed_dists, $installed_provides,
        $installed_prereqs_required, $installs, $to_remove  ) = @_;

    foreach my $inst_dist_meta (@$installed_meta) {
        push @{ $installed_modules->{ $inst_dist_meta->{name} } }, $inst_dist_meta->{dist};
        $installed_dists->{ $inst_dist_meta->{dist} } = $inst_dist_meta;
    }

    # Now that we have an index of installed dists and installed_modules, make a list of installed_provides
    # and installed_prereqs_required

    foreach my $module_name ( keys %$installed_modules ) {
        my $dist_meta = $self->get_specified_dist($module_name, $installed_modules, $installed_dists, $installs, $to_remove );
        next unless $dist_meta;

        my $provides = $dist_meta->{provides};
        if ( scalar keys %$provides == 0 ) {
            $self->print("Distribution " . $dist_meta->{name} . " does not have any 'provides'. Indexing may be broken.\n", ERROR);
        }
        for my $mod ( keys %$provides ) {
            $installed_provides->{$mod} = $dist_meta;
        }
        my $prereqs = $dist_meta->{mymeta}{prereqs};
        # add runtime prereqs
        for my $mod ( keys %{$prereqs->{runtime}->{requires}} ) {
            $installed_prereqs_required->{$mod}++;
        }
        # add configures prereqs
        for my $mod ( keys %{$prereqs->{configure}->{requires}} ) {
            $installed_prereqs_required->{$mod}++;
        }
    }
}

sub get_specified_dist {
    my ( $self, $module_name, $installed_modules, $installed_dists, $installs, $to_remove ) = @_;

    my $verbose = $self->{verbose};
    # save distributions that will be saved and removed
    # check for duplicate distributions installed, and remove non-pinned or lower version
    my @dists = @{ $installed_modules->{$module_name} };
    my $dist_meta;
    if ( scalar @dists == 1 ) {
        my $dist = $dists[0];
        $installs->{$module_name} = $installed_dists->{$dist};
        $dist_meta = $installed_dists->{$dist};
    }
    else {
        $self->print( "Checking $module_name\n", INFO ) if $verbose;
        my $matched = 0;
        my $not_matched;
        foreach my $dist (@dists) {
            if ( $self->modspec->is_pinned_to( $module_name, $dist ) ) {
                $self->print( "...Keeping pinned $dist\n", INFO ) if $verbose;
                $installs->{$module_name} = $installed_dists->{$dist};
                $dist_meta = $installed_dists->{$dist};
                $matched = 1;
            }
            else {
                $self->print( "...Possible duplicate $dist\n", INFO ) if $verbose;
                $not_matched->{$dist} = $installed_dists->{$dist};
            }
        }
        if ( $matched ) {
            # if we found a pinned dist, add the non-pinned dists to the to_remove list
            foreach my $dist ( keys %$not_matched ) {
                $to_remove->{$dist} = $not_matched->{$dist};
            }
        }
        else {
            $self->print( "...Multiple versions of $module_name\n", INFO ) if $verbose;
            my $highest_version = 0;
            my $highest_dist_meta;
            foreach my $dist (@dists) {
                my $this_dist_meta = $installed_dists->{$dist};
                if ( version->parse($this_dist_meta->{version}) > version->parse($highest_version) ) {
                    $highest_version = $this_dist_meta->{version};
                    $highest_dist_meta = $this_dist_meta;
                }
            }
            if ($highest_version) {
                $dist_meta = $highest_dist_meta;
                # messages and update $installs and $to_remove
                foreach my $dist (@dists) {
                    my $this_dist_meta = $installed_dists->{$dist};
                    if ( version->parse($this_dist_meta->{version}) == version->parse($highest_version) ) {
                        $self->print( "...Keeping version $highest_version, $dist\n", INFO )
                            if $verbose;
                        $installs->{$module_name} = $this_dist_meta;
                    }
                    else {
                        $self->print( "...Would remove $dist\n", INFO ) if $verbose;
                        $to_remove->{$dist} = $this_dist_meta;
                    }
                }
            }
            else {
                $self->print(
                    "Unable to determine highest version of $module_name. Skipping.\n",
                    ERROR );
            }
        }
    }
    return $dist_meta;
}

=head2 build_mirror_meta_and_clean

=cut

sub build_mirror_meta_and_clean {
    my ( $self, $installs, $to_remove) = @_;

    my $meta_dir = "$self->{path}/lib/perl5/$Config{archname}/.meta";
    # remove the unneeded files.
    $self->print( "Removing packages in local mirror that have not been installed.\n", INFO )
        if keys %$to_remove;
    my $num_removed = 0;
    foreach my $dist ( keys %$to_remove ) {
        my $meta = $to_remove->{$dist};
        $self->print( "Removing $dist\n", INFO );
        # remove meta
        my $dist_meta_dir = "$meta_dir/$dist";
        $self->print( "...Removing $dist_meta_dir\n", INFO );
        remove_tree($dist_meta_dir);
        # remove archives from local library
        my $pathname = $meta->{pathname};
        my $archive  = $self->local_mirror . "/authors/id/$pathname";
        $self->print( "...Removing $archive\n", INFO );
        unlink($archive);
        $num_removed++;
    }
    $self->print( "Removed $num_removed distributions\n", INFO );

    # to make the json file smaller, we only save the
    # info that we use. (55k lines instead of 130k, for example)
    my $cleaned_installs = {};
    while ( my ($mod, $meta) = each %$installs ) {
        $cleaned_installs->{$mod} = {
            provides => $meta->{provides},
            version => $meta->{version},
            dist => $meta->{dist},
            pathname => $meta->{pathname},
            name => $meta->{name},
            mymeta => {
                prereqs => $meta->{mymeta}{prereqs},
            },
        };
    }
    my $mirror_meta = {
        modules => $cleaned_installs,
        version => 2,
    };
    $self->{mirror_meta} = $mirror_meta;

    my $file = $self->mirror_meta_file;
    dump_json( $mirror_meta, $file );
}

=head2 check_installed_against_mirror_meta

=cut

sub check_installed_against_mirror_meta {
    my $self = shift;

    my $mirror_meta = $self->mirror_meta->{modules};
    my %mirror_dists;
    foreach my $meta ( values %$mirror_meta ) {
        $mirror_dists{ $meta->{dist} } = $meta;
    }
    my $mirror_count = scalar keys %mirror_dists;
    $self->print( "Found $mirror_count distributions in the mirror meta.\n", INFO );

    my $installed_meta = $self->gather_installed_meta;
    my %installed_dists;
    foreach my $meta (@$installed_meta) {
        $installed_dists{ $meta->{dist} } = $meta;
    }
    my $installed_count = scalar keys %installed_dists;
    $self->print( "Found $installed_count distributions in the installed meta.\n", INFO );

    if ( $mirror_count == $installed_count ) {
        $self->print(
            "Number of distributions in mirror meta is equal to number of distributions installed.\n",
            SUCCESS
        );
    }
    else {
        $self->print(
            "Number of distributions in mirror meta is NOT equal to number of distributions installed.\n",
            ERROR
        );
    }

    my $errors = 0;
    foreach my $dist ( keys %installed_dists ) {
        unless ( exists $mirror_dists{$dist} ) {
            $self->print( "Dist $dist is installed but not in mirror meta.\n", ERROR );
            $errors++;
        }
    }
    foreach my $dist ( keys %mirror_dists ) {
        unless ( exists $installed_dists{$dist} ) {
            $self->print( "Dist $dist is in the mirror meta, but is not installed.\n", ERROR );
            $errors++;
        }
    }
    if ($errors) {
        $self->print( "Found $errors errors when comparing mirror meta to installed meta.\n",
            ERROR );
    }
    else {
        $self->print( "Found no errors when comparing mirror meta to installed meta.\n",
            SUCCESS );
    }
    return $errors;
}

=head meta_needs_install

=cut

sub meta_needs_install {
    my $self = shift;

    my $mirror_meta = $self->mirror_meta->{modules};
    my %mirror_dists;
    foreach my $meta ( values %$mirror_meta ) {
        $mirror_dists{ $meta->{dist} } = $meta;
    }
    my $installed_meta = $self->gather_installed_meta;
    my %installed_dists;
    foreach my $meta (@$installed_meta) {
        $installed_dists{ $meta->{dist} } = $meta;
    }
    my @needs_install;
    foreach my $dist ( keys %mirror_dists ) {
        unless ( exists $installed_dists{$dist} ) {
            push @needs_install, $dist;
        }
    }
    return \@needs_install;
}

=head2 needs_install

Determine whether extlib needs to be installed
by examining a json file saved on each install

=cut

sub needs_install {
    my $self = shift;

    my $last_run_file = $self->last_run_file;
    return 1 unless ( -f $last_run_file );

    my $last_run_stats = load_json($last_run_file);
    my $last_run_md5   = $last_run_stats->{mirror_meta_md5};
    return 1 unless $last_run_md5;

    my $current_md5 = file_md5_hex( $self->mirror_meta_file );
    return 1 if ( $last_run_md5 ne $current_md5 );

    return 0;
}

=head2 save_last_run

=cut

sub save_last_run {
    my $self = shift;

    my $last_run_file = $self->last_run_file;
    my ( undef, $dir ) = splitpath($last_run_file);
    if ( not -d $dir ) {
        make_path($dir);
    }

    dump_json(
        {
            date            => ( scalar localtime() ),
            mirror_meta_md5 => file_md5_hex( $self->mirror_meta_file ),
        },
        $last_run_file,
    );
}

=head2 get_mirror_archives

Returns hashref of:

   Net-SSLeay-1.54 => { pathname => M/MI/MIKEM/Net-SSLeay-1.54.tar.gz }

=cut

sub get_mirror_archives {
    my $self = shift;

    my %archives;
    my $authors_dir = $self->local_mirror . '/authors/id';
    my $wanted      = sub {
        if ( $_ =~ /.tar.gz$/ || $_ =~ /.tgz$/ || $_ =~ /.zip$/ ) {
            my $dist = $_;
            $dist =~ s/(.tar.gz|.tgz|.zip)$//;
            my $name = $File::Find::name;
            $name =~ s/$authors_dir//g;
            $archives{$dist} = { pathname => $name };
        }
    };
    File::Find::find( $wanted, $authors_dir );

    return \%archives;
}

=head2 clean_local_mirror

This runs after the extlib.json has been created, and so uses
that and not the gathered meta.

=cut

sub clean_local_mirror {
    my $self = shift;

    my @meta     = values %{ $self->mirror_meta->{modules} };
    my $archives = $self->get_mirror_archives;

    my %dists = map { ( $_->{dist} => $_ ); } @meta;

    $self->print( "Looking for unneeded archives in library..\n", INFO );

    $self->print( "Removing packages from local mirror that were not installed\n", INFO );
    foreach my $dist ( keys %$archives ) {
        unless ( exists $dists{$dist} ) {
            my $archive_path = $archives->{$dist}->{pathname};
            if ( -e $archive_path ) {
                $self->print( "Removing $dist\n", INFO );
                unlink( $archive_path );
            }
        }
    }
}

=head2 build_index

This is used to build 02packages.details.txt. It creates a hashref of
package provided by a distribution to the metadata.

=cut

sub build_index {
    my $self = shift;

    my $modules = $self->mirror_meta->{modules};
    my $index;
    while ( my ( $name, $metadata ) = each %$modules ) {
        my $provides = $metadata->{provides};
        if ( scalar keys %$provides == 0 ) {
            $self->print("Dist $name has no provides. Attempting to fix. If later errors occur, dist might need patching.\n", ERROR);
            $provides->{$name} = { version => $metadata->{version} };
        }
        for my $mod ( keys %$provides ) {
            # this is a kludge because cpanm doesn't honor no_index package
            # fixes IPC::ShareLite and Data::Structure::Util
            next if $provides->{$mod}->{file} =~ /^inc\//;
            $index->{$mod} = {  %{ $provides->{$mod} }, meta => $metadata };
        }
    }
    $self->{index} = $index;
}

sub dedupe_modules {
    my ( $self, $modules ) = @_;

    my %seen;
    my @result;
    for my $spec ( reverse @$modules ) {
        my ( $mod, $ver ) = split /~/, $spec;
        next if $seen{$mod}++;
        push @result, $spec;
    }

    return [ reverse @result ];
}

sub load_json {
    my $file = shift;

    local $/;
    open( my $fh, "<", $file ) or die "cannot open $file for reading: $!";
    # decode_json is equivalent of Cpanel::JSON::XS->new->utf8->decode(..)
    return decode_json( join ('', <$fh>) );
}

sub dump_json {
    my ( $data, $file ) = @_;

    open( my $fh, ">", $file ) or die "cannot open $file for writing: $!";
    binmode($fh);
    # not using encode_json because we also want canonical (to preserve hash ordering)
    # and 'pretty', for nice formatting
    print $fh Cpanel::JSON::XS->new->pretty->canonical->utf8->encode($data);
}

=head2 build_package_details

=cut

sub build_packages_details {
    my $self = shift;

    my $mirror_meta_file = $self->mirror_meta_file;
    $self->print( "Building 02packages.details.txt from $mirror_meta_file\n", INFO );

    my $index = $self->index;
    my @packages;
    for my $package ( sort keys %$index ) {
        my $module = $index->{$package};
        push @packages, [ $package, $module->{version}, $module->{meta}{pathname} ];
    }
    my $file     = $self->packages_details_file;
    my $fh;
    if ( $file =~ /\.gz$/i ) {
        $fh = IO::Compress::Gzip->new($file) or die $IO::Compress::Gzip::GzipError;
    }
    else {
        open $fh, ">", $file or die $!;
    }

    print $fh <<EOF;
File:         02packages.details.txt
URL:          http://www.perl.com/CPAN/modules/02packages.details.txt
Description:  Package names found in $mirror_meta_file
Columns:      package name, version, path
Intended-For: Automated fetch routines, namespace documentation.
Written-By:   Extlib
Line-Count:   @{[ scalar(@packages) ]}
Last-Updated: @{[ scalar localtime ]}

EOF
    for my $p (@packages) {
        print $fh sprintf "%s %s  %s\n", pad( $p->[0], 32 ), pad( $p->[1] || 'undef', 10, 1 ),
            $p->[2];
    }

    $self->print( "Created $file\n", SUCCESS );
}

=head2 get_mirror_meta

=cut

sub get_mirror_meta {
    my $self = shift;

    unless ( -e $self->mirror_meta_file ) {
        die "no file specified for mirror meta";
    }

    my $mirror_meta_file = $self->mirror_meta_file;
    my $mirror_meta;
    try {
        $mirror_meta = load_json( $self->mirror_meta_file );
    }
    catch {
        if (/No such file/) {
            $self->print( "Can't locate $mirror_meta_file\n", ERROR );
        }
        else {
            $self->print( "Can't parse $mirror_meta_file: $_\n", ERROR );
        }
    };

    $self->{mirror_meta} = $mirror_meta;
}

=head2 install

Install, separating out modules to force and not force.

=cut

sub install {
    my ( $self, %args ) = @_;

    my $modules = $args{modules};
    my $force = [];
    my $notforce = [];

    if ($modules) {
        foreach my $module (@$modules) {
            my $info = $self->modspec->config->{$module};
            # $info here is undef if there's no config in modules.yaml
            if ( $info ) {
                if ( $info->{force} ) {
                    push @$force, $info->{path} || $module;
                }
                else {
                    push @$notforce, $info->{path} || $module;
                }
            }
            else {
                push @$notforce, $module;
            }
        }
    }
    else {
        ( $force, $notforce ) = $self->modspec->force_notforce_modules;
    }
    my $notforce_rc = 0;
    if ( scalar @$notforce ) {
        $notforce_rc = $self->install_modules( $notforce, undef, cpanm_args => $args{cpanm_args} );
        # $self->copy_build_log;
    }

    my $force_rc = 0;
    if ( scalar @$force ) {
        $force_rc = $self->install_modules( $force, 'force', cpanm_args => $args{cpanm_args} );
        # $self->copy_build_log('force.build.log');
    }
    return $notforce_rc || $force_rc;
}

sub copy_build_log {
    my ( $self, $build_log_copy ) = @_;
    $build_log_copy ||= 'build.log';
    my $build_log = $ENV{HOME} . '/.cpanm/build.log';
    my $filepath = io($build_log)->canonpath;
    if ( $filepath ) {
        # io($build_log_copy)->unlink;
        io($filepath) > io($build_log_copy);
        $self->print("Copied $filepath to current directory as $build_log_copy\n", INFO);
    }
}

=head2 install_modules

'--mirror-only' means that it only searches the mirrors listed in args instead
of the 'database'.

=cut

sub install_modules {
    my ( $self, $modules, $force, %args ) = @_;

    $self->print( "Started installing modules\n", INFO );
    my @cpanm_args = $args{cpanm_args} ? ( @{ $args{cpanm_args} } ) : ();
    my $cpanm    = $self->{cpanm_executable} || 'cpanm';
    my $mirror   = $self->local_mirror;
    my @force    = $force ? ('--force') : ();
    my @commands = (
        $cpanm,
        '-L', $self->{path},
        '--self-contained',
        '--mirror-only',
        '--quiet',
        '--notest',
        @force,
        @cpanm_args,
        '--auto-cleanup', 1,
        '--mirror', $mirror,
        @$modules,
    );
    warn "command => " . join(' ', @commands);
    system(@commands);
    my $rc = $?;
    $self->print( "Finished installing modules\n", INFO );
    return $rc;
}

=head2 install_for_update

Install when doing an update, but all modules at once.

Note: the local mirror *must* come after the external mirror,
otherwise lots of install will fail for prereqs.

=cut

sub install_for_update {
    my $self = shift;

    my @cpanm_args = (
        '--mirror-only',
        "--mirror", $DefaultMirror,
        "--mirror", $self->local_mirror,
        "--mirror", "http://backpan.perl.org/",    # fallback
        '--reinstall',
        "--cascade-search",
        "--save-dists", $self->local_mirror,
    );

    # remove already installed local lib so we have a fresh start
    my $perl_tree = $self->path . "/lib/perl5";
    remove_tree($perl_tree);

    $self->install( cpanm_args => \@cpanm_args );
}

=head2 install_full

This is used when we want a full install of all packages, but do not
want to refresh from CPAN. Uses our mirror only. It's not like plain
'install' in that it does a '--reinstall', after removing the install
directories..

=cut

sub install_full {
    my $self = shift;

    # remove already installed local lib so we have a fresh start
    my $perl_tree = $self->path . "/lib/perl5";
    remove_tree($perl_tree);
    $self->install( cpanm_args => ['--reinstall'] );

}

=head2 install_for_update_individually

Install each dist individually instead of in a batch, like the
complete source update.

=cut

sub install_for_update_individually {
    my ( $self, %args ) = @_;

    my $modules = $args{modules};
    $modules ||= [ $self->module_list ];
    my $cpanm = $self->{cpanm_executable} || 'cpanm';
    my @error_modules;
    my $succeeded = 0;
    local $ENV{PERL_CPANM_OPT};
    foreach my $module (@$modules) {
        unless ( exists $self->modspec->config->{$module} ) {
            $self->print("$module is not specified in module config\n", ERROR);
            push @error_modules, $module;
            next;
        }
        my $info = $self->modspec->config->{$module};
        my @force = $info->{force} ? ('--force') : ();
        # use a pinned path if specified
        $module = $info->{path} if $info->{path};
        $self->print( "---- Installing $module ----\n", INFO );
        # --self-contained is not necessary because -L sets it
        # --reinstall is necessary for a first-time re-build, because otherwise it
        # won't install packages that are in the system Perl library
        # --reinstall forces everything to reinstall
        my @commands = (
            $cpanm,
            "--quiet",
            "-L", $self->{path},
            "--self-contained",
            "--reinstall",
            "--notest",
            "--mirror-only",
            "--mirror", $DefaultMirror,
            "--mirror", $self->local_mirror,
            "--mirror", "http://backpan.perl.org/",    # fallback
            "--cascade-search",
            "--save-dists",   $self->local_mirror,
            "--auto-cleanup", 1,
            @force,
            $module,
        );
        try {
            system(@commands);
        }
        catch {
            push @error_modules, $module;
        }
        finally {
            $succeeded++;
        };
    }
    $self->print( "Errors installing " . scalar @error_modules . " modules\n", ERROR )
        if scalar @error_modules;
    $self->print( "Succeeded in installing $succeeded modules\n", INFO );
    $self->print( "Total modules => " . scalar @$modules . "\n",  INFO );

    return $succeeded;
}

=head2 verify_all_installed

=cut

sub verify_all_installed {
    my $self = shift;

    my ( $installs, $to_remove ) = $self->gather_installed_meta;

    if ( keys %$to_remove ) {
        $self->print( "Some packages were not installed\n", ERROR );
        my $count = 0;
        foreach my $dist ( keys %$to_remove ) {
            $self->print( "....$dist\n", INFO );
            $count++;
        }
        $self->print( "$count packages were not installed\n", ERROR );
    }
    else {
        $self->print( "All packages were installed\n", SUCCESS );
    }
    return keys %$to_remove ? 0 : 1;
}

=head2 update_metadata_fast

This accepts a list of packages to install or update and rebuilds
the metadata with just the added/changed packages. It will not handle
removing packages that no longer need to be installed.

This assumes that the packages have already been installed via
'install_for_update_individually'.

It's very similar to '', but doesn't do some of the sanity
checks on the installed packages, since the local lib is not guaranteed
to be all installed.

=cut

sub update_metadata_fast  {
    my ( $self, %args ) = @_;

    my $modules = $args{modules};

    my $installed_meta = $self->gather_installed_meta;
    # Index the meta records by 1) module name to distributions in %installed_modules,
    # 2) dist name in %installed_dists, 3) provided packages in %installed_provides.
    # There could be more than one distribution per module name
    my %installed_modules;
    my %installed_dists;
    my %installed_provides;
    my %installed_prereqs_required;
    my %installs;
    $self->index_installed_meta(
        $installed_meta,
        \%installed_modules,
        \%installed_dists,
        \%installed_provides,
        \%installed_prereqs_required,
        \%installs
    );

    # check for packages specified that didn't get installed
    my $meta_dir = "$self->{path}/lib/perl5/$Config{archname}/.meta";
    $self->print("Checking that modules have been installed.\n", INFO);
    foreach my $module_name ( @$modules ) {
        $self->print("'Provides' for $module_name not found in $meta_dir. It may not have been installed, or install.json is incorrect\n", ERROR)
            unless exists $installed_provides{$module_name};
    }

    # get the meta from extlib.json
    my $mirror_meta = $self->mirror_meta;
    my $old_meta_modules = $mirror_meta->{modules};

    # recurse through the modules and their prereqs
    my $possibly_new = {};
    my $to_remove = {};
    my $errors = 0;
    my %prereqs;
    @prereqs{@$modules} = ();
    $self->find_prereqs( \%installed_provides, $possibly_new, \%prereqs, $old_meta_modules, $to_remove, 'top' );

    # replace or add keys in old_meta_modules with newly installed dists
    foreach my $added_mod ( keys %$possibly_new ) {
        $self->print("Adding $added_mod to existing metadata\n", INFO);
        $old_meta_modules->{$added_mod} = $possibly_new->{$added_mod};
    }

    # write out extlib.json and 02packages.details.txt.gz
    $self->build_mirror_meta_and_clean( $old_meta_modules, $to_remove );
}

sub find_prereqs {
    my ( $self, $installed_provides, $possibly_new, $prereqs, $old_meta_modules, $to_remove, $top ) = @_;

    my $new_prereqs = {};
    foreach my $mod (keys %$prereqs) {
        next if $mod eq 'perl';
        next if $self->is_core($mod, 0);
        if ( exists $installed_provides->{$mod} ) {
            # meta from dists installed into local lib
            my $new_meta = $installed_provides->{$mod};
            my $module_name = $new_meta->{name};
            # meta from extlib.json
            my $old_meta = $old_meta_modules->{$module_name};
            if ( $old_meta ) {
                # could be installing lower pinned version. could be leftover older versions in lib
                if ( ($top && $old_meta->{version} ne $new_meta->{version} ) ||
                     (version->parse($old_meta->{version}) < version->parse($new_meta->{version})) ) {
                    # keep track of removals
                    $to_remove->{$old_meta->{dist}} = $old_meta;
                    $self->print("\nRemoving: $module_name, version =>" . $old_meta->{version} . "\n", INFO);
                    # keep track of adds
                    $possibly_new->{$module_name} = $new_meta;
                    $self->print("Adding: $mod, version => $new_meta->{version}\n\n", INFO);
                }
                # else versions are equal, no change
            }
            else {
                # this is a totally new package, keep track of adds
                $possibly_new->{$module_name} = $new_meta;
                $self->print("Adding: $module_name, version => $new_meta->{version}\n", INFO);
            }
            # prepare for the next round of prereq checking
            my $mod_prereqs = $self->merge_prereqs($new_meta->{mymeta}{prereqs});
            foreach my $prereq_mod ( keys %$mod_prereqs ) {
                # this won't catch prereqs specified by package name instead of dist,
                # but might enable skipping some
                unless ( exists $possibly_new->{$prereq_mod} ) {
                    $new_prereqs->{$prereq_mod} = $mod_prereqs->{$prereq_mod};
                }
            }
        }
        else {
            # prereq not installed, must be core
            next;
        }
    }
    if ( keys %$new_prereqs ) {
        $self->find_prereqs( $installed_provides, $possibly_new, $new_prereqs, $old_meta_modules, $to_remove );
    }
    else {
        return;
    }
}

=head2 Tree and list methods
################################################################

=cut

sub list_from_mirror {
    my $self        = shift;
    my $mirror_meta = $self->mirror_meta->{modules};
    my $meta_array  = [ values %$mirror_meta ];
    $self->list($meta_array);
}

# takes an array of meta hashrefs
sub list {
    my ( $self, $meta_array ) = @_;
    for my $module (@$meta_array) {
        $self->print("$module->{dist}\n");
    }
}

sub display_tree_from_mirror {
    my $self        = shift;
    my $mirror_meta = $self->mirror_meta->{modules};
    $self->display_tree($mirror_meta);
}

# For this to work, the $meta_href passed in must only include
# requested dists, not all dists.
# Not currently used. Not necessarily working correctly.
sub collect_dists_to_remove {
    my ( $self, $meta_href, $skip ) = @_;

    my $tree = $self->build_tree($meta_href);
    my $stop = 0;
    my %dists_to_keep;
    my %dists_to_remove;
    $self->walk_down_tree(
        $tree,
        sub {
            my ( $module, $depth ) = @_;
            $stop = 0 if ( $depth == 0 );
            $stop = 1 if ( exists $skip->{$module->{dist}} );
            if ( $stop ) {
                $dists_to_remove{$module->{dist}} = 1;
            }
            else {
                $dists_to_keep{$module->{dist}} = 1;
            }
        }
    );
    delete @dists_to_remove{keys %dists_to_keep};
    return \%dists_to_remove;
}


=head2 display_tree

=cut

# takes a hashref of module_name => meta_hashref
sub display_tree {
    my ( $self, $meta_href ) = @_;

    # $meta_href is $mirror_meta->{modules}
    my $tree = $self->build_tree($meta_href);
    $self->walk_down_tree(
        $tree,
        sub {
            my ( $module, $depth ) = @_;
            my $line = "  " x $depth . "$module->{dist}\n";
            $self->print($line);
        }
    );
}

=head2 walk_down_tree

=cut

sub walk_down_tree {
    my ( $self, $tree, $cb, $no_warn ) = @_;

    my %seen;
    $tree->walk_down(
        sub {
            my ( $node, $depth, $parent ) = @_;
            return $tree->abort if $seen{ $node->key }++;

            if ( $node->metadata->{dist} ) {
                $cb->( $node->metadata, $depth );
            }
            elsif ( !$self->is_core( $node->key, 0 ) && !$no_warn ) {
                warn "Couldn't find ", $node->key, ", listed by  ", $parent->metadata->{dist}, "\n";
            }
        }
    );
}

=head2 build_tree

=cut

sub build_tree {
    my ( $self, $modules, $root ) = @_;

    my $idx  = $self->build_index($modules);
    my $pool = {%$modules};                    # copy

    my $tree = Extlib::Tree->new;

    while ( my $pick = ( keys %$pool )[0] ) {
        $self->_build_tree( $pick, $tree, $tree, $pool, $idx );
    }

    $tree->finalize($root);

    return $tree;
}

sub _build_tree {
    my ( $self, $elem, $tree, $curr_node, $pool, $idx ) = @_;

    if ( my $cached = Extlib::TreeNode->cached($elem) ) {
        $curr_node->add_child($cached);
        return;
    }

    my $node = Extlib::TreeNode->new( $elem, $pool );
    $curr_node->add_child($node);

    for my $child ( $self->build_deps( $node->metadata, $idx ) ) {
        $self->_build_tree( $child, $tree, $node, $pool, $idx );
    }
}

sub is_core {
    my ( $self, $module, $want_ver, $perl_version ) = @_;
    $perl_version ||= $];

    my $is_core = exists $Module::CoreList::version{ $perl_version + 0 }{$module} or
        return;

    my $core_ver = $Module::CoreList::version{ $perl_version + 0 }{$module};
    return 1 unless $want_ver;
    return version->new($core_ver) >= version->new($want_ver);
}

sub merge_prereqs {
    my ( $self, $prereqs ) = @_;

    my %requires;
    #   There are loops in requirements... Only doing runtime & configure.
    #   for my $phase (qw( configure build test runtime )) {
    for my $phase ( ('runtime', 'configure') ) {
        %requires = ( %requires, %{ $prereqs->{$phase}{requires} || {} } );
    }

    return \%requires;
}

sub build_deps {
    my ( $self, $meta, $idx ) = @_;

    # get runtime and configure prereqs
    my $requires = $self->merge_prereqs( $meta->{mymeta}{prereqs} );

    my @deps;
    for my $module ( keys %$requires ) {
        next if $module eq 'perl';
        if ( exists $idx->{$module} ) {
            push @deps, $idx->{$module}{meta}{name};
        }
        else {
            push @deps, $module;
        }
    }

    return @deps;
}

1;
